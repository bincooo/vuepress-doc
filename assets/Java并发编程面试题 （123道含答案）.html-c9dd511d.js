const l=JSON.parse('{"key":"v-7829dff6","path":"/guide/markdown/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%20%EF%BC%88123%E9%81%93%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.html","title":"","lang":"zh-CN","frontmatter":{"description":"目录 一、基础知识 1. 为什么要使用并发编程 2. 多线程应用场景 3. 并发编程有什么缺点 4. 并发编程三个必要因素是什么？ 5. Java 程序中怎么保证多线程的运行安全？ 6. 并行和并发有什么区别？ 7. 什么是多线程 8. 多线程的好处 9. 多线程的劣势： 10. 线程和进程区别 11. 什么是上下文切换? 12. 守护线程和用户线程有什么区别呢？ 13. 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？ 14. 什么是线程死锁 15. 形成死锁的四个必要条件是什么 16. 如何避免线程死锁 17. 创建线程的四种方式 18. 说一下 runnable 和 callable 有什么区别 19. 线程的 run()和 start()有什么区别？ 20. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？ 21. 什么是 Callable 和 Future? 22. 什么是 FutureTask 23. 线程的状态 24. Java 中用到的线程调度算法是什么？ 25. 线程的调度策略 26. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？ 27. 请说出与线程同步以及线程调度相关的方法。 28. sleep() 和 wait() 有什么区别？ 29. 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？ 30. 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？ 31. 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？ 32. Thread 类中的 yield 方法有什么作用？ 33. 为什么 Thread 类的 sleep()和 yield ()方法是静态的？ 34. 线程的 sleep()方法和 yield()方法有什么区别？ 35. 如何停止一个正在运行的线程？ 36. Java 中 interrupted 和 isInterrupted 方法的区别？ 37. 什么是阻塞式方法？ 38. Java 中你怎样唤醒一个阻塞的线程？ 39. notify() 和 notifyAll() 有什么区别？ 40. 如何在两个线程间共享数据？ 41. Java 如何实现多线程之间的通讯和协作？ 42. 同步方法和同步块，哪个是更好的选择？ 43. 什么是线程同步和线程互斥，有哪几种实现方式？ 44. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 45. 如果你提交任务时，线程池队列已满，这时会发生什么 46. 什么叫线程安全？servlet 是线程安全吗? 47. 在 Java 程序中怎么保证多线程的运行安全？ 48. 你对线程优先级的理解是什么？ 49. 线程类的构造方法、静态块是被哪个线程调用的 50. Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？ 51. 一个线程运行时发生异常会怎样？ 52. Java 线程数过多会造成什么异常？ 53. 多线程的常用方法 二、并发理论 1. Java中垃圾回收有什么目的？什么时候进行垃圾回收？ 2. 线程之间如何通信及线程之间如何同步 3. Java内存模型 4. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 5. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 6. 什么是重排序 7. 重排序实际执行的指令步骤 8. 重排序遵守的规则 9. as-if-serial规则和happens-before规则的区别 10. 并发关键字 synchronized ？ 11. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗 12. 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！” 13. 说一下 synchronized 底层实现原理？ 14. synchronized可重入的原理 15. 什么是自旋 16. 多线程中 synchronized 锁升级的原理是什么？ 17. 线程 B 怎么知道线程 A 修改了变量 18. 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？ 19. synchronized、volatile、CAS 比较 20. synchronized 和 Lock 有什么区别？ 21. synchronized 和 ReentrantLock 区别是什么？ 22. volatile 关键字的作用 23. Java 中能创建 volatile 数组吗？ 24. volatile 变量和 atomic 变量有什么不同？ 25. volatile 能使得一个非原子操作变成原子操作吗？ 26. synchronized 和 volatile 的区别是什么？ 27. final不可变对象，它对写并发应用有什么帮助？ 28. Lock 接口和synchronized 对比同步它有什么优势？ 29. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？ 30. 什么是 CAS 31. CAS 的会产生什么问题？ 32. 什么是原子类 33. 原子类的常用类 34. 说一下 Atomic的原理？ 35. 死锁与活锁的区别，死锁与饥饿的区别？ 三、线程池 1. 什么是线程池？ 2. 线程池作用？ 3. 线程池有什么优点？ 4. 什么是ThreadPoolExecutor？ 5. 什么是Executors？ 6. 线程池四种创建方式？ 7. 在 Java 中 Executor 和 Executors 的区别？ 8. 四种构建线程池的区别及特点？ 9. 线程池都有哪些状态？ 10. 线程池中 submit() 和 execute() 方法有什么区别？ 11. 什么是线程组，为什么在 Java 中不推荐使用？ 12. ThreadPoolExecutor饱和策略有哪些？ 13. 如何自定义线程线程池? 14. 线程池的执行原理？ 15. 如何合理分配线程池大小? 四、并发容器 1. 你经常使用什么并发容器，为什么？ 2. 什么是Vector 3. ArrayList和Vector有什么不同之处？ 4. 为什么HashTable是线程安全的？ 5. 用过ConcurrentHashMap，讲一下他和HashTable的不同之处？ 6. Collections.synchronized * 是什么？ 7. Java 中 ConcurrentHashMap 的并发度是什么？ 8. 什么是并发容器的实现？ 9. Java 中的同步集合与并发集合有什么区别？ 10. SynchronizedMap 和 ConcurrentHashMap 有什么区别？ 11. CopyOnWriteArrayList 是什么? 12. CopyOnWriteArrayList 的使用场景? 13. CopyOnWriteArrayList 的缺点? 14. CopyOnWriteArrayList 的设计思想? 五、并发队列 1. 什么是并发队列： 2. 并发队列和并发集合的区别： 3. 怎么判断并发队列是阻塞队列还是非阻塞队列 4. 阻塞队列和非阻塞队列区别 5. 常用并发列队的介绍： 六、并发工具类 1. 常用的并发工具类有哪些？","head":[["meta",{"property":"og:url","content":"https://www.icu-web.tk/vuepress-doc/guide/markdown/Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%20%EF%BC%88123%E9%81%93%E5%90%AB%E7%AD%94%E6%A1%88%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"折戟沉沙、丿"}],["meta",{"property":"og:description","content":"目录 一、基础知识 1. 为什么要使用并发编程 2. 多线程应用场景 3. 并发编程有什么缺点 4. 并发编程三个必要因素是什么？ 5. Java 程序中怎么保证多线程的运行安全？ 6. 并行和并发有什么区别？ 7. 什么是多线程 8. 多线程的好处 9. 多线程的劣势： 10. 线程和进程区别 11. 什么是上下文切换? 12. 守护线程和用户线程有什么区别呢？ 13. 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？ 14. 什么是线程死锁 15. 形成死锁的四个必要条件是什么 16. 如何避免线程死锁 17. 创建线程的四种方式 18. 说一下 runnable 和 callable 有什么区别 19. 线程的 run()和 start()有什么区别？ 20. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？ 21. 什么是 Callable 和 Future? 22. 什么是 FutureTask 23. 线程的状态 24. Java 中用到的线程调度算法是什么？ 25. 线程的调度策略 26. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？ 27. 请说出与线程同步以及线程调度相关的方法。 28. sleep() 和 wait() 有什么区别？ 29. 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？ 30. 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？ 31. 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？ 32. Thread 类中的 yield 方法有什么作用？ 33. 为什么 Thread 类的 sleep()和 yield ()方法是静态的？ 34. 线程的 sleep()方法和 yield()方法有什么区别？ 35. 如何停止一个正在运行的线程？ 36. Java 中 interrupted 和 isInterrupted 方法的区别？ 37. 什么是阻塞式方法？ 38. Java 中你怎样唤醒一个阻塞的线程？ 39. notify() 和 notifyAll() 有什么区别？ 40. 如何在两个线程间共享数据？ 41. Java 如何实现多线程之间的通讯和协作？ 42. 同步方法和同步块，哪个是更好的选择？ 43. 什么是线程同步和线程互斥，有哪几种实现方式？ 44. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？ 45. 如果你提交任务时，线程池队列已满，这时会发生什么 46. 什么叫线程安全？servlet 是线程安全吗? 47. 在 Java 程序中怎么保证多线程的运行安全？ 48. 你对线程优先级的理解是什么？ 49. 线程类的构造方法、静态块是被哪个线程调用的 50. Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？ 51. 一个线程运行时发生异常会怎样？ 52. Java 线程数过多会造成什么异常？ 53. 多线程的常用方法 二、并发理论 1. Java中垃圾回收有什么目的？什么时候进行垃圾回收？ 2. 线程之间如何通信及线程之间如何同步 3. Java内存模型 4. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 5. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 6. 什么是重排序 7. 重排序实际执行的指令步骤 8. 重排序遵守的规则 9. as-if-serial规则和happens-before规则的区别 10. 并发关键字 synchronized ？ 11. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗 12. 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！” 13. 说一下 synchronized 底层实现原理？ 14. synchronized可重入的原理 15. 什么是自旋 16. 多线程中 synchronized 锁升级的原理是什么？ 17. 线程 B 怎么知道线程 A 修改了变量 18. 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？ 19. synchronized、volatile、CAS 比较 20. synchronized 和 Lock 有什么区别？ 21. synchronized 和 ReentrantLock 区别是什么？ 22. volatile 关键字的作用 23. Java 中能创建 volatile 数组吗？ 24. volatile 变量和 atomic 变量有什么不同？ 25. volatile 能使得一个非原子操作变成原子操作吗？ 26. synchronized 和 volatile 的区别是什么？ 27. final不可变对象，它对写并发应用有什么帮助？ 28. Lock 接口和synchronized 对比同步它有什么优势？ 29. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？ 30. 什么是 CAS 31. CAS 的会产生什么问题？ 32. 什么是原子类 33. 原子类的常用类 34. 说一下 Atomic的原理？ 35. 死锁与活锁的区别，死锁与饥饿的区别？ 三、线程池 1. 什么是线程池？ 2. 线程池作用？ 3. 线程池有什么优点？ 4. 什么是ThreadPoolExecutor？ 5. 什么是Executors？ 6. 线程池四种创建方式？ 7. 在 Java 中 Executor 和 Executors 的区别？ 8. 四种构建线程池的区别及特点？ 9. 线程池都有哪些状态？ 10. 线程池中 submit() 和 execute() 方法有什么区别？ 11. 什么是线程组，为什么在 Java 中不推荐使用？ 12. ThreadPoolExecutor饱和策略有哪些？ 13. 如何自定义线程线程池? 14. 线程池的执行原理？ 15. 如何合理分配线程池大小? 四、并发容器 1. 你经常使用什么并发容器，为什么？ 2. 什么是Vector 3. ArrayList和Vector有什么不同之处？ 4. 为什么HashTable是线程安全的？ 5. 用过ConcurrentHashMap，讲一下他和HashTable的不同之处？ 6. Collections.synchronized * 是什么？ 7. Java 中 ConcurrentHashMap 的并发度是什么？ 8. 什么是并发容器的实现？ 9. Java 中的同步集合与并发集合有什么区别？ 10. SynchronizedMap 和 ConcurrentHashMap 有什么区别？ 11. CopyOnWriteArrayList 是什么? 12. CopyOnWriteArrayList 的使用场景? 13. CopyOnWriteArrayList 的缺点? 14. CopyOnWriteArrayList 的设计思想? 五、并发队列 1. 什么是并发队列： 2. 并发队列和并发集合的区别： 3. 怎么判断并发队列是阻塞队列还是非阻塞队列 4. 阻塞队列和非阻塞队列区别 5. 常用并发列队的介绍： 六、并发工具类 1. 常用的并发工具类有哪些？"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-05T14:04:17.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-05T14:04:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-05T14:04:17.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":3,"title":"目录","slug":"目录","link":"#目录","children":[]},{"level":2,"title":"一、基础知识","slug":"一、基础知识","link":"#一、基础知识","children":[]},{"level":2,"title":"1. 为什么要使用并发编程","slug":"_1-为什么要使用并发编程","link":"#_1-为什么要使用并发编程","children":[]},{"level":2,"title":"2. 多线程应用场景","slug":"_2-多线程应用场景","link":"#_2-多线程应用场景","children":[]},{"level":2,"title":"3. 并发编程有什么缺点","slug":"_3-并发编程有什么缺点","link":"#_3-并发编程有什么缺点","children":[]},{"level":2,"title":"4. 并发编程三个必要因素是什么？","slug":"_4-并发编程三个必要因素是什么","link":"#_4-并发编程三个必要因素是什么","children":[]},{"level":2,"title":"5. Java 程序中怎么保证多线程的运行安全？","slug":"_5-java-程序中怎么保证多线程的运行安全","link":"#_5-java-程序中怎么保证多线程的运行安全","children":[]},{"level":2,"title":"6. 并行和并发有什么区别？","slug":"_6-并行和并发有什么区别","link":"#_6-并行和并发有什么区别","children":[]},{"level":2,"title":"7. 什么是多线程","slug":"_7-什么是多线程","link":"#_7-什么是多线程","children":[]},{"level":2,"title":"8. 多线程的好处","slug":"_8-多线程的好处","link":"#_8-多线程的好处","children":[]},{"level":2,"title":"9. 多线程的劣势：","slug":"_9-多线程的劣势","link":"#_9-多线程的劣势","children":[]},{"level":2,"title":"10. 线程和进程区别","slug":"_10-线程和进程区别","link":"#_10-线程和进程区别","children":[]},{"level":2,"title":"11. 什么是上下文切换?","slug":"_11-什么是上下文切换","link":"#_11-什么是上下文切换","children":[]},{"level":2,"title":"12. 守护线程和用户线程有什么区别呢？","slug":"_12-守护线程和用户线程有什么区别呢","link":"#_12-守护线程和用户线程有什么区别呢","children":[]},{"level":2,"title":"13. 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？","slug":"_13-如何在-windows-和-linux-上查找哪个线程cpu利用率最高","link":"#_13-如何在-windows-和-linux-上查找哪个线程cpu利用率最高","children":[]},{"level":2,"title":"14. 什么是线程死锁","slug":"_14-什么是线程死锁","link":"#_14-什么是线程死锁","children":[]},{"level":2,"title":"15. 形成死锁的四个必要条件是什么","slug":"_15-形成死锁的四个必要条件是什么","link":"#_15-形成死锁的四个必要条件是什么","children":[]},{"level":2,"title":"16. 如何避免线程死锁","slug":"_16-如何避免线程死锁","link":"#_16-如何避免线程死锁","children":[]},{"level":2,"title":"17. 创建线程的四种方式","slug":"_17-创建线程的四种方式","link":"#_17-创建线程的四种方式","children":[]},{"level":2,"title":"18. 说一下 runnable 和 callable 有什么区别","slug":"_18-说一下-runnable-和-callable-有什么区别","link":"#_18-说一下-runnable-和-callable-有什么区别","children":[]},{"level":2,"title":"19. 线程的 run()和 start()有什么区别？","slug":"_19-线程的-run-和-start-有什么区别","link":"#_19-线程的-run-和-start-有什么区别","children":[]},{"level":2,"title":"20. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？","slug":"_20-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用run-方法","link":"#_20-为什么我们调用-start-方法时会执行-run-方法-为什么我们不能直接调用run-方法","children":[]},{"level":2,"title":"21. 什么是 Callable 和 Future?","slug":"_21-什么是-callable-和-future","link":"#_21-什么是-callable-和-future","children":[]},{"level":2,"title":"22. 什么是 FutureTask","slug":"_22-什么是-futuretask","link":"#_22-什么是-futuretask","children":[]},{"level":2,"title":"23. 线程的状态","slug":"_23-线程的状态","link":"#_23-线程的状态","children":[]},{"level":2,"title":"24. Java 中用到的线程调度算法是什么？","slug":"_24-java-中用到的线程调度算法是什么","link":"#_24-java-中用到的线程调度算法是什么","children":[]},{"level":2,"title":"25. 线程的调度策略","slug":"_25-线程的调度策略","link":"#_25-线程的调度策略","children":[]},{"level":2,"title":"26. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？","slug":"_26-什么是线程调度器-thread-scheduler-和时间分片-time-slicing","link":"#_26-什么是线程调度器-thread-scheduler-和时间分片-time-slicing","children":[]},{"level":2,"title":"27. 请说出与线程同步以及线程调度相关的方法。","slug":"_27-请说出与线程同步以及线程调度相关的方法。","link":"#_27-请说出与线程同步以及线程调度相关的方法。","children":[]},{"level":2,"title":"28. sleep() 和 wait() 有什么区别？","slug":"_28-sleep-和-wait-有什么区别","link":"#_28-sleep-和-wait-有什么区别","children":[]},{"level":2,"title":"29. 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？","slug":"_29-你是如何调用-wait-方法的-使用-if-块还是循环-为什么","link":"#_29-你是如何调用-wait-方法的-使用-if-块还是循环-为什么","children":[]},{"level":2,"title":"30. 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？","slug":"_30-为什么线程通信的方法-wait-notify-和-notifyall-被定义在-object-类里","link":"#_30-为什么线程通信的方法-wait-notify-和-notifyall-被定义在-object-类里","children":[]},{"level":2,"title":"31. 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？","slug":"_31-为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用","link":"#_31-为什么-wait-notify-和-notifyall-必须在同步方法或者同步块中被调用","children":[]},{"level":2,"title":"32. Thread 类中的 yield 方法有什么作用？","slug":"_32-thread-类中的-yield-方法有什么作用","link":"#_32-thread-类中的-yield-方法有什么作用","children":[]},{"level":2,"title":"33. 为什么 Thread 类的 sleep()和 yield ()方法是静态的？","slug":"_33-为什么-thread-类的-sleep-和-yield-方法是静态的","link":"#_33-为什么-thread-类的-sleep-和-yield-方法是静态的","children":[]},{"level":2,"title":"34. 线程的 sleep()方法和 yield()方法有什么区别？","slug":"_34-线程的-sleep-方法和-yield-方法有什么区别","link":"#_34-线程的-sleep-方法和-yield-方法有什么区别","children":[]},{"level":2,"title":"35. 如何停止一个正在运行的线程？","slug":"_35-如何停止一个正在运行的线程","link":"#_35-如何停止一个正在运行的线程","children":[]},{"level":2,"title":"36. Java 中 interrupted 和 isInterrupted 方法的区别？","slug":"_36-java-中-interrupted-和-isinterrupted-方法的区别","link":"#_36-java-中-interrupted-和-isinterrupted-方法的区别","children":[]},{"level":2,"title":"37. 什么是阻塞式方法？","slug":"_37-什么是阻塞式方法","link":"#_37-什么是阻塞式方法","children":[]},{"level":2,"title":"38. Java 中你怎样唤醒一个阻塞的线程？","slug":"_38-java-中你怎样唤醒一个阻塞的线程","link":"#_38-java-中你怎样唤醒一个阻塞的线程","children":[]},{"level":2,"title":"39. notify() 和 notifyAll() 有什么区别？","slug":"_39-notify-和-notifyall-有什么区别","link":"#_39-notify-和-notifyall-有什么区别","children":[]},{"level":2,"title":"40. 如何在两个线程间共享数据？","slug":"_40-如何在两个线程间共享数据","link":"#_40-如何在两个线程间共享数据","children":[]},{"level":2,"title":"41. Java 如何实现多线程之间的通讯和协作？","slug":"_41-java-如何实现多线程之间的通讯和协作","link":"#_41-java-如何实现多线程之间的通讯和协作","children":[]},{"level":2,"title":"42. 同步方法和同步块，哪个是更好的选择？","slug":"_42-同步方法和同步块-哪个是更好的选择","link":"#_42-同步方法和同步块-哪个是更好的选择","children":[]},{"level":2,"title":"43. 什么是线程同步和线程互斥，有哪几种实现方式？","slug":"_43-什么是线程同步和线程互斥-有哪几种实现方式","link":"#_43-什么是线程同步和线程互斥-有哪几种实现方式","children":[]},{"level":2,"title":"44. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？","slug":"_44-在监视器-monitor-内部-是如何做线程同步的-程序应该做哪种级别的同步","link":"#_44-在监视器-monitor-内部-是如何做线程同步的-程序应该做哪种级别的同步","children":[]},{"level":2,"title":"45. 如果你提交任务时，线程池队列已满，这时会发生什么","slug":"_45-如果你提交任务时-线程池队列已满-这时会发生什么","link":"#_45-如果你提交任务时-线程池队列已满-这时会发生什么","children":[]},{"level":2,"title":"46. 什么叫线程安全？servlet 是线程安全吗?","slug":"_46-什么叫线程安全-servlet-是线程安全吗","link":"#_46-什么叫线程安全-servlet-是线程安全吗","children":[]},{"level":2,"title":"47. 在 Java 程序中怎么保证多线程的运行安全？","slug":"_47-在-java-程序中怎么保证多线程的运行安全","link":"#_47-在-java-程序中怎么保证多线程的运行安全","children":[]},{"level":2,"title":"48. 你对线程优先级的理解是什么？","slug":"_48-你对线程优先级的理解是什么","link":"#_48-你对线程优先级的理解是什么","children":[]},{"level":2,"title":"49. 线程类的构造方法、静态块是被哪个线程调用的","slug":"_49-线程类的构造方法、静态块是被哪个线程调用的","link":"#_49-线程类的构造方法、静态块是被哪个线程调用的","children":[]},{"level":2,"title":"50. Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？","slug":"_50-java-中怎么获取一份线程-dump-文件-你如何在-java-中获取线程堆栈","link":"#_50-java-中怎么获取一份线程-dump-文件-你如何在-java-中获取线程堆栈","children":[]},{"level":2,"title":"51. 一个线程运行时发生异常会怎样？","slug":"_51-一个线程运行时发生异常会怎样","link":"#_51-一个线程运行时发生异常会怎样","children":[]},{"level":2,"title":"52. Java 线程数过多会造成什么异常？","slug":"_52-java-线程数过多会造成什么异常","link":"#_52-java-线程数过多会造成什么异常","children":[]},{"level":2,"title":"53. 多线程的常用方法","slug":"_53-多线程的常用方法","link":"#_53-多线程的常用方法","children":[]},{"level":2,"title":"二、并发理论","slug":"二、并发理论","link":"#二、并发理论","children":[]},{"level":2,"title":"1. Java中垃圾回收有什么目的？什么时候进行垃圾回收？","slug":"_1-java中垃圾回收有什么目的-什么时候进行垃圾回收","link":"#_1-java中垃圾回收有什么目的-什么时候进行垃圾回收","children":[]},{"level":2,"title":"2. 线程之间如何通信及线程之间如何同步","slug":"_2-线程之间如何通信及线程之间如何同步","link":"#_2-线程之间如何通信及线程之间如何同步","children":[]},{"level":2,"title":"3. Java内存模型","slug":"_3-java内存模型","link":"#_3-java内存模型","children":[]},{"level":2,"title":"4. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？","slug":"_4-如果对象的引用被置为null-垃圾收集器是否会立即释放对象占用的内存","link":"#_4-如果对象的引用被置为null-垃圾收集器是否会立即释放对象占用的内存","children":[]},{"level":2,"title":"5. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？","slug":"_5-finalize-方法什么时候被调用-析构函数-finalization-的目的是什么","link":"#_5-finalize-方法什么时候被调用-析构函数-finalization-的目的是什么","children":[]},{"level":2,"title":"6. 什么是重排序","slug":"_6-什么是重排序","link":"#_6-什么是重排序","children":[]},{"level":2,"title":"7. 重排序实际执行的指令步骤","slug":"_7-重排序实际执行的指令步骤","link":"#_7-重排序实际执行的指令步骤","children":[]},{"level":2,"title":"8. 重排序遵守的规则","slug":"_8-重排序遵守的规则","link":"#_8-重排序遵守的规则","children":[]},{"level":2,"title":"9. as-if-serial规则和happens-before规则的区别","slug":"_9-as-if-serial规则和happens-before规则的区别","link":"#_9-as-if-serial规则和happens-before规则的区别","children":[]},{"level":2,"title":"10. 并发关键字 synchronized ？","slug":"_10-并发关键字-synchronized","link":"#_10-并发关键字-synchronized","children":[]},{"level":2,"title":"11. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗","slug":"_11-说说自己是怎么使用-synchronized-关键字-在项目中用到了吗","link":"#_11-说说自己是怎么使用-synchronized-关键字-在项目中用到了吗","children":[]},{"level":2,"title":"12. 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”","slug":"_12-单例模式了解吗-给我解释一下双重检验锁方式实现单例模式","link":"#_12-单例模式了解吗-给我解释一下双重检验锁方式实现单例模式","children":[]},{"level":2,"title":"13. 说一下 synchronized 底层实现原理？","slug":"_13-说一下-synchronized-底层实现原理","link":"#_13-说一下-synchronized-底层实现原理","children":[]},{"level":2,"title":"14. synchronized可重入的原理","slug":"_14-synchronized可重入的原理","link":"#_14-synchronized可重入的原理","children":[]},{"level":2,"title":"15. 什么是自旋","slug":"_15-什么是自旋","link":"#_15-什么是自旋","children":[]},{"level":2,"title":"16. 多线程中 synchronized 锁升级的原理是什么？","slug":"_16-多线程中-synchronized-锁升级的原理是什么","link":"#_16-多线程中-synchronized-锁升级的原理是什么","children":[]},{"level":2,"title":"17. 线程 B 怎么知道线程 A 修改了变量","slug":"_17-线程-b-怎么知道线程-a-修改了变量","link":"#_17-线程-b-怎么知道线程-a-修改了变量","children":[]},{"level":2,"title":"18. 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？","slug":"_18-当一个线程进入一个对象的-synchronized-方法-a-之后-其它线程是否可进入此对象的-synchronized-方法-b","link":"#_18-当一个线程进入一个对象的-synchronized-方法-a-之后-其它线程是否可进入此对象的-synchronized-方法-b","children":[]},{"level":2,"title":"19. synchronized、volatile、CAS 比较","slug":"_19-synchronized、volatile、cas-比较","link":"#_19-synchronized、volatile、cas-比较","children":[]},{"level":2,"title":"20. synchronized 和 Lock 有什么区别？","slug":"_20-synchronized-和-lock-有什么区别","link":"#_20-synchronized-和-lock-有什么区别","children":[]},{"level":2,"title":"21. synchronized 和 ReentrantLock 区别是什么？","slug":"_21-synchronized-和-reentrantlock-区别是什么","link":"#_21-synchronized-和-reentrantlock-区别是什么","children":[]},{"level":2,"title":"22. volatile 关键字的作用","slug":"_22-volatile-关键字的作用","link":"#_22-volatile-关键字的作用","children":[]},{"level":2,"title":"23. Java 中能创建 volatile 数组吗？","slug":"_23-java-中能创建-volatile-数组吗","link":"#_23-java-中能创建-volatile-数组吗","children":[]},{"level":2,"title":"24. volatile 变量和 atomic 变量有什么不同？","slug":"_24-volatile-变量和-atomic-变量有什么不同","link":"#_24-volatile-变量和-atomic-变量有什么不同","children":[]},{"level":2,"title":"25. volatile 能使得一个非原子操作变成原子操作吗？","slug":"_25-volatile-能使得一个非原子操作变成原子操作吗","link":"#_25-volatile-能使得一个非原子操作变成原子操作吗","children":[]},{"level":2,"title":"26. synchronized 和 volatile 的区别是什么？","slug":"_26-synchronized-和-volatile-的区别是什么","link":"#_26-synchronized-和-volatile-的区别是什么","children":[]},{"level":2,"title":"27. final不可变对象，它对写并发应用有什么帮助？","slug":"_27-final不可变对象-它对写并发应用有什么帮助","link":"#_27-final不可变对象-它对写并发应用有什么帮助","children":[]},{"level":2,"title":"28. Lock 接口和synchronized 对比同步它有什么优势？","slug":"_28-lock-接口和synchronized-对比同步它有什么优势","link":"#_28-lock-接口和synchronized-对比同步它有什么优势","children":[]},{"level":2,"title":"29. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？","slug":"_29-乐观锁和悲观锁的理解及如何实现-有哪些实现方式","link":"#_29-乐观锁和悲观锁的理解及如何实现-有哪些实现方式","children":[]},{"level":2,"title":"30. 什么是 CAS","slug":"_30-什么是-cas","link":"#_30-什么是-cas","children":[]},{"level":2,"title":"31. CAS 的会产生什么问题？","slug":"_31-cas-的会产生什么问题","link":"#_31-cas-的会产生什么问题","children":[]},{"level":2,"title":"32. 什么是原子类","slug":"_32-什么是原子类","link":"#_32-什么是原子类","children":[]},{"level":2,"title":"33. 原子类的常用类","slug":"_33-原子类的常用类","link":"#_33-原子类的常用类","children":[]},{"level":2,"title":"34. 说一下 Atomic的原理？","slug":"_34-说一下-atomic的原理","link":"#_34-说一下-atomic的原理","children":[]},{"level":2,"title":"35. 死锁与活锁的区别，死锁与饥饿的区别？","slug":"_35-死锁与活锁的区别-死锁与饥饿的区别","link":"#_35-死锁与活锁的区别-死锁与饥饿的区别","children":[]},{"level":2,"title":"三、线程池","slug":"三、线程池","link":"#三、线程池","children":[]},{"level":2,"title":"1. 什么是线程池？","slug":"_1-什么是线程池","link":"#_1-什么是线程池","children":[]},{"level":2,"title":"2. 线程池作用？","slug":"_2-线程池作用","link":"#_2-线程池作用","children":[]},{"level":2,"title":"3. 线程池有什么优点？","slug":"_3-线程池有什么优点","link":"#_3-线程池有什么优点","children":[]},{"level":2,"title":"4. 什么是ThreadPoolExecutor？","slug":"_4-什么是threadpoolexecutor","link":"#_4-什么是threadpoolexecutor","children":[]},{"level":2,"title":"5. 什么是Executors？","slug":"_5-什么是executors","link":"#_5-什么是executors","children":[]},{"level":2,"title":"6. 线程池四种创建方式？","slug":"_6-线程池四种创建方式","link":"#_6-线程池四种创建方式","children":[]},{"level":2,"title":"7. 在 Java 中 Executor 和 Executors 的区别？","slug":"_7-在-java-中-executor-和-executors-的区别","link":"#_7-在-java-中-executor-和-executors-的区别","children":[]},{"level":2,"title":"8. 四种构建线程池的区别及特点？","slug":"_8-四种构建线程池的区别及特点","link":"#_8-四种构建线程池的区别及特点","children":[]},{"level":2,"title":"9. 线程池都有哪些状态？","slug":"_9-线程池都有哪些状态","link":"#_9-线程池都有哪些状态","children":[]},{"level":2,"title":"10. 线程池中 submit() 和 execute() 方法有什么区别？","slug":"_10-线程池中-submit-和-execute-方法有什么区别","link":"#_10-线程池中-submit-和-execute-方法有什么区别","children":[]},{"level":2,"title":"11. 什么是线程组，为什么在 Java 中不推荐使用？","slug":"_11-什么是线程组-为什么在-java-中不推荐使用","link":"#_11-什么是线程组-为什么在-java-中不推荐使用","children":[]},{"level":2,"title":"12. ThreadPoolExecutor饱和策略有哪些？","slug":"_12-threadpoolexecutor饱和策略有哪些","link":"#_12-threadpoolexecutor饱和策略有哪些","children":[]},{"level":2,"title":"13. 如何自定义线程线程池?","slug":"_13-如何自定义线程线程池","link":"#_13-如何自定义线程线程池","children":[]},{"level":2,"title":"14. 线程池的执行原理？","slug":"_14-线程池的执行原理","link":"#_14-线程池的执行原理","children":[]},{"level":2,"title":"15. 如何合理分配线程池大小?","slug":"_15-如何合理分配线程池大小","link":"#_15-如何合理分配线程池大小","children":[]},{"level":2,"title":"四、并发容器","slug":"四、并发容器","link":"#四、并发容器","children":[]},{"level":2,"title":"1. 你经常使用什么并发容器，为什么？","slug":"_1-你经常使用什么并发容器-为什么","link":"#_1-你经常使用什么并发容器-为什么","children":[]},{"level":2,"title":"2. 什么是Vector","slug":"_2-什么是vector","link":"#_2-什么是vector","children":[]},{"level":2,"title":"3. ArrayList和Vector有什么不同之处？","slug":"_3-arraylist和vector有什么不同之处","link":"#_3-arraylist和vector有什么不同之处","children":[]},{"level":2,"title":"4. 为什么HashTable是线程安全的？","slug":"_4-为什么hashtable是线程安全的","link":"#_4-为什么hashtable是线程安全的","children":[]},{"level":2,"title":"5. 用过ConcurrentHashMap，讲一下他和HashTable的不同之处？","slug":"_5-用过concurrenthashmap-讲一下他和hashtable的不同之处","link":"#_5-用过concurrenthashmap-讲一下他和hashtable的不同之处","children":[]},{"level":2,"title":"6. Collections.synchronized * 是什么？","slug":"_6-collections-synchronized-是什么","link":"#_6-collections-synchronized-是什么","children":[]},{"level":2,"title":"7. Java 中 ConcurrentHashMap 的并发度是什么？","slug":"_7-java-中-concurrenthashmap-的并发度是什么","link":"#_7-java-中-concurrenthashmap-的并发度是什么","children":[]},{"level":2,"title":"8. 什么是并发容器的实现？","slug":"_8-什么是并发容器的实现","link":"#_8-什么是并发容器的实现","children":[]},{"level":2,"title":"9. Java 中的同步集合与并发集合有什么区别？","slug":"_9-java-中的同步集合与并发集合有什么区别","link":"#_9-java-中的同步集合与并发集合有什么区别","children":[]},{"level":2,"title":"10. SynchronizedMap 和 ConcurrentHashMap 有什么区别？","slug":"_10-synchronizedmap-和-concurrenthashmap-有什么区别","link":"#_10-synchronizedmap-和-concurrenthashmap-有什么区别","children":[]},{"level":2,"title":"11. CopyOnWriteArrayList 是什么?","slug":"_11-copyonwritearraylist-是什么","link":"#_11-copyonwritearraylist-是什么","children":[]},{"level":2,"title":"12. CopyOnWriteArrayList 的使用场景?","slug":"_12-copyonwritearraylist-的使用场景","link":"#_12-copyonwritearraylist-的使用场景","children":[]},{"level":2,"title":"13. CopyOnWriteArrayList 的缺点?","slug":"_13-copyonwritearraylist-的缺点","link":"#_13-copyonwritearraylist-的缺点","children":[]},{"level":2,"title":"14. CopyOnWriteArrayList 的设计思想?","slug":"_14-copyonwritearraylist-的设计思想","link":"#_14-copyonwritearraylist-的设计思想","children":[]},{"level":2,"title":"五、并发队列","slug":"五、并发队列","link":"#五、并发队列","children":[]},{"level":2,"title":"1. 什么是并发队列：","slug":"_1-什么是并发队列","link":"#_1-什么是并发队列","children":[]},{"level":2,"title":"2. 并发队列和并发集合的区别：","slug":"_2-并发队列和并发集合的区别","link":"#_2-并发队列和并发集合的区别","children":[]},{"level":2,"title":"3. 怎么判断并发队列是阻塞队列还是非阻塞队列","slug":"_3-怎么判断并发队列是阻塞队列还是非阻塞队列","link":"#_3-怎么判断并发队列是阻塞队列还是非阻塞队列","children":[]},{"level":2,"title":"4. 阻塞队列和非阻塞队列区别","slug":"_4-阻塞队列和非阻塞队列区别","link":"#_4-阻塞队列和非阻塞队列区别","children":[]},{"level":2,"title":"5. 常用并发列队的介绍：","slug":"_5-常用并发列队的介绍","link":"#_5-常用并发列队的介绍","children":[]},{"level":2,"title":"六、并发工具类","slug":"六、并发工具类","link":"#六、并发工具类","children":[]},{"level":2,"title":"1. 常用的并发工具类有哪些？","slug":"_1-常用的并发工具类有哪些","link":"#_1-常用的并发工具类有哪些","children":[]}],"git":{"createdTime":1693922657000,"updatedTime":1693922657000,"contributors":[{"name":"bincooo","email":"admin@bincooodeiMac.local","commits":1}]},"readingTime":{"minutes":94.57,"words":28371},"filePathRelative":"guide/markdown/Java面试宝典/Java并发编程面试题 （123道含答案）.md","localizedDate":"2023年9月5日","excerpt":"<h3> 目录</h3>\\n<ul>\\n<li><a href=\\"#_1\\">一、基础知识</a></li>\\n<li>\\n<ul>\\n<li><a href=\\"#1__2\\">1. 为什么要使用并发编程</a></li>\\n<li><a href=\\"#2__13\\">2. 多线程应用场景</a></li>\\n<li><a href=\\"#3__16\\">3. 并发编程有什么缺点</a></li>\\n<li><a href=\\"#4__21\\">4. 并发编程三个必要因素是什么？</a></li>\\n<li><a href=\\"#5_Java__27\\">5. Java 程序中怎么保证多线程的运行安全？</a></li>\\n<li><a href=\\"#6__33\\">6. 并行和并发有什么区别？</a></li>\\n<li><a href=\\"#7__45\\">7. 什么是多线程</a></li>\\n<li><a href=\\"#8__49\\">8. 多线程的好处</a></li>\\n<li><a href=\\"#9__54\\">9. 多线程的劣势：</a></li>\\n<li><a href=\\"#10__59\\">10. 线程和进程区别</a></li>\\n<li><a href=\\"#11__82\\">11. 什么是上下文切换?</a></li>\\n<li><a href=\\"#12__96\\">12. 守护线程和用户线程有什么区别呢？</a></li>\\n<li><a href=\\"#13__Windows__Linux_cpu_102\\">13. 如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？</a></li>\\n<li><a href=\\"#14__112\\">14. 什么是线程死锁</a></li>\\n<li><a href=\\"#15__121\\">15. 形成死锁的四个必要条件是什么</a></li>\\n<li><a href=\\"#16__131\\">16. 如何避免线程死锁</a></li>\\n<li><a href=\\"#17__136\\">17. 创建线程的四种方式</a></li>\\n<li><a href=\\"#18__runnable__callable__180\\">18. 说一下 runnable 和 callable 有什么区别</a></li>\\n<li><a href=\\"#19__run_start_192\\">19. 线程的 run()和 start()有什么区别？</a></li>\\n<li><a href=\\"#20__start__run_run__206\\">20. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用run() 方法？</a></li>\\n<li><a href=\\"#21__Callable__Future_218\\">21. 什么是 Callable 和 Future?</a></li>\\n<li><a href=\\"#22__FutureTask_225\\">22. 什么是 FutureTask</a></li>\\n<li><a href=\\"#23__232\\">23. 线程的状态</a></li>\\n<li><a href=\\"#24_Java__253\\">24. Java 中用到的线程调度算法是什么？</a></li>\\n<li><a href=\\"#25__266\\">25. 线程的调度策略</a></li>\\n<li><a href=\\"#26_Thread_SchedulerTime_Slicing__274\\">26. 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？</a></li>\\n<li><a href=\\"#27__282\\">27. 请说出与线程同步以及线程调度相关的方法。</a></li>\\n<li><a href=\\"#28_sleep__wait__291\\">28. sleep() 和 wait() 有什么区别？</a></li>\\n<li><a href=\\"#29__wait__if__300\\">29. 你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？</a></li>\\n<li><a href=\\"#30__wait_notify_notifyAll_Object__317\\">30. 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？</a></li>\\n<li><a href=\\"#31__wait_notify_notifyAll_326\\">31. 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</a></li>\\n<li><a href=\\"#32_Thread__yield__333\\">32. Thread 类中的 yield 方法有什么作用？</a></li>\\n<li><a href=\\"#33__Thread__sleep_yield__338\\">33. 为什么 Thread 类的 sleep()和 yield ()方法是静态的？</a></li>\\n<li><a href=\\"#34__sleep_yield_343\\">34. 线程的 sleep()方法和 yield()方法有什么区别？</a></li>\\n<li><a href=\\"#35__352\\">35. 如何停止一个正在运行的线程？</a></li>\\n<li><a href=\\"#36_Java__interrupted__isInterrupted__359\\">36. Java 中 interrupted 和 isInterrupted 方法的区别？</a></li>\\n<li><a href=\\"#37__366\\">37. 什么是阻塞式方法？</a></li>\\n<li><a href=\\"#38_Java__371\\">38. Java 中你怎样唤醒一个阻塞的线程？</a></li>\\n<li><a href=\\"#39_notify__notifyAll__379\\">39. notify() 和 notifyAll() 有什么区别？</a></li>\\n<li><a href=\\"#40__387\\">40. 如何在两个线程间共享数据？</a></li>\\n<li><a href=\\"#41_Java__391\\">41. Java 如何实现多线程之间的通讯和协作？</a></li>\\n<li><a href=\\"#42__406\\">42. 同步方法和同步块，哪个是更好的选择？</a></li>\\n<li><a href=\\"#43__415\\">43. 什么是线程同步和线程互斥，有哪几种实现方式？</a></li>\\n<li><a href=\\"#44_Monitor_436\\">44. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</a></li>\\n<li><a href=\\"#45__444\\">45. 如果你提交任务时，线程池队列已满，这时会发生什么</a></li>\\n<li><a href=\\"#46_servlet__451\\">46. 什么叫线程安全？servlet 是线程安全吗?</a></li>\\n<li><a href=\\"#47__Java__462\\">47. 在 Java 程序中怎么保证多线程的运行安全？</a></li>\\n<li><a href=\\"#48__480\\">48. 你对线程优先级的理解是什么？</a></li>\\n<li><a href=\\"#49__490\\">49. 线程类的构造方法、静态块是被哪个线程调用的</a></li>\\n<li><a href=\\"#50_Java__dump__Java__498\\">50. Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？</a></li>\\n<li><a href=\\"#51__504\\">51. 一个线程运行时发生异常会怎样？</a></li>\\n<li><a href=\\"#52_Java__510\\">52. Java 线程数过多会造成什么异常？</a></li>\\n<li><a href=\\"#53__521\\">53. 多线程的常用方法</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#_539\\">二、并发理论</a></li>\\n<li>\\n<ul>\\n<li><a href=\\"#1_Java_540\\">1. Java中垃圾回收有什么目的？什么时候进行垃圾回收？</a></li>\\n<li><a href=\\"#2__544\\">2. 线程之间如何通信及线程之间如何同步</a></li>\\n<li><a href=\\"#3_Java_551\\">3. Java内存模型</a></li>\\n<li><a href=\\"#4_null_569\\">4. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？</a></li>\\n<li><a href=\\"#5_finalizefinalization_573\\">5. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？</a></li>\\n<li><a href=\\"#6__585\\">6. 什么是重排序</a></li>\\n<li><a href=\\"#7__602\\">7. 重排序实际执行的指令步骤</a></li>\\n<li><a href=\\"#8__611\\">8. 重排序遵守的规则</a></li>\\n<li><a href=\\"#9_asifserialhappensbefore_618\\">9. as-if-serial规则和happens-before规则的区别</a></li>\\n<li><a href=\\"#10__synchronized__627\\">10. 并发关键字 synchronized ？</a></li>\\n<li><a href=\\"#11__synchronized__639\\">11. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</a></li>\\n<li><a href=\\"#12__654\\">12. 单例模式了解吗？给我解释一下双重检验锁方式实现单例模式！”</a></li>\\n<li><a href=\\"#13__synchronized__688\\">13. 说一下 synchronized 底层实现原理？</a></li>\\n<li><a href=\\"#14_synchronized_700\\">14. synchronized可重入的原理</a></li>\\n<li><a href=\\"#15__705\\">15. 什么是自旋</a></li>\\n<li><a href=\\"#16__synchronized__716\\">16. 多线程中 synchronized 锁升级的原理是什么？</a></li>\\n<li><a href=\\"#17__B__A__735\\">17. 线程 B 怎么知道线程 A 修改了变量</a></li>\\n<li><a href=\\"#18__synchronized__A__synchronized__B_741\\">18. 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</a></li>\\n<li><a href=\\"#19_synchronizedvolatileCAS__746\\">19. synchronized、volatile、CAS 比较</a></li>\\n<li><a href=\\"#20_synchronized__Lock__751\\">20. synchronized 和 Lock 有什么区别？</a></li>\\n<li><a href=\\"#21_synchronized__ReentrantLock__758\\">21. synchronized 和 ReentrantLock 区别是什么？</a></li>\\n<li><a href=\\"#22_volatile__781\\">22. volatile 关键字的作用</a></li>\\n<li><a href=\\"#23_Java__volatile__787\\">23. Java 中能创建 volatile 数组吗？</a></li>\\n<li><a href=\\"#24_volatile__atomic__792\\">24. volatile 变量和 atomic 变量有什么不同？</a></li>\\n<li><a href=\\"#25_volatile__798\\">25. volatile 能使得一个非原子操作变成原子操作吗？</a></li>\\n<li><a href=\\"#26_synchronized__volatile__812\\">26. synchronized 和 volatile 的区别是什么？</a></li>\\n<li><a href=\\"#27_final_829\\">27. final不可变对象，它对写并发应用有什么帮助？</a></li>\\n<li><a href=\\"#28_Lock_synchronized__840\\">28. Lock 接口和synchronized 对比同步它有什么优势？</a></li>\\n<li><a href=\\"#29__853\\">29. 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</a></li>\\n<li><a href=\\"#30__CAS_864\\">30. 什么是 CAS</a></li>\\n<li><a href=\\"#31_CAS__878\\">31. CAS 的会产生什么问题？</a></li>\\n<li><a href=\\"#32__886\\">32. 什么是原子类</a></li>\\n<li><a href=\\"#33__897\\">33. 原子类的常用类</a></li>\\n<li><a href=\\"#34__Atomic_903\\">34. 说一下 Atomic的原理？</a></li>\\n<li><a href=\\"#35__908\\">35. 死锁与活锁的区别，死锁与饥饿的区别？</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#_926\\">三、线程池</a></li>\\n<li>\\n<ul>\\n<li><a href=\\"#1__927\\">1. 什么是线程池？</a></li>\\n<li><a href=\\"#2__935\\">2. 线程池作用？</a></li>\\n<li><a href=\\"#3__942\\">3. 线程池有什么优点？</a></li>\\n<li><a href=\\"#4_ThreadPoolExecutor_950\\">4. 什么是ThreadPoolExecutor？</a></li>\\n<li><a href=\\"#5_Executors_966\\">5. 什么是Executors？</a></li>\\n<li><a href=\\"#6__977\\">6. 线程池四种创建方式？</a></li>\\n<li><a href=\\"#7__Java__Executor__Executors__984\\">7. 在 Java 中 Executor 和 Executors 的区别？</a></li>\\n<li><a href=\\"#8__991\\">8. 四种构建线程池的区别及特点？</a></li>\\n<li><a href=\\"#9__1109\\">9. 线程池都有哪些状态？</a></li>\\n<li><a href=\\"#10__submit__execute__1117\\">10. 线程池中 submit() 和 execute() 方法有什么区别？</a></li>\\n<li><a href=\\"#11__Java__1125\\">11. 什么是线程组，为什么在 Java 中不推荐使用？</a></li>\\n<li><a href=\\"#12_ThreadPoolExecutor_1133\\">12. ThreadPoolExecutor饱和策略有哪些？</a></li>\\n<li><a href=\\"#13__1143\\">13. 如何自定义线程线程池?</a></li>\\n<li><a href=\\"#14__1183\\">14. 线程池的执行原理？</a></li>\\n<li><a href=\\"#15__1194\\">15. 如何合理分配线程池大小?</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#_1224\\">四、并发容器</a></li>\\n<li>\\n<ul>\\n<li><a href=\\"#1__1225\\">1. 你经常使用什么并发容器，为什么？</a></li>\\n<li><a href=\\"#2_Vector_1231\\">2. 什么是Vector</a></li>\\n<li><a href=\\"#3_ArrayListVector_1237\\">3. ArrayList和Vector有什么不同之处？</a></li>\\n<li><a href=\\"#4_HashTable_1246\\">4. 为什么HashTable是线程安全的？</a></li>\\n<li><a href=\\"#5_ConcurrentHashMapHashTable_1254\\">5. 用过ConcurrentHashMap，讲一下他和HashTable的不同之处？</a></li>\\n<li><a href=\\"#6_Collectionssynchronized___1273\\">6. Collections.synchronized * 是什么？</a></li>\\n<li><a href=\\"#7_Java__ConcurrentHashMap__1278\\">7. Java 中 ConcurrentHashMap 的并发度是什么？</a></li>\\n<li><a href=\\"#8__1285\\">8. 什么是并发容器的实现？</a></li>\\n<li><a href=\\"#9_Java__1297\\">9. Java 中的同步集合与并发集合有什么区别？</a></li>\\n<li><a href=\\"#10_SynchronizedMap__ConcurrentHashMap__1303\\">10. SynchronizedMap 和 ConcurrentHashMap 有什么区别？</a></li>\\n<li><a href=\\"#11_CopyOnWriteArrayList__1315\\">11. CopyOnWriteArrayList 是什么?</a></li>\\n<li><a href=\\"#12_CopyOnWriteArrayList__1322\\">12. CopyOnWriteArrayList 的使用场景?</a></li>\\n<li><a href=\\"#13_CopyOnWriteArrayList__1325\\">13. CopyOnWriteArrayList 的缺点?</a></li>\\n<li><a href=\\"#14_CopyOnWriteArrayList__1334\\">14. CopyOnWriteArrayList 的设计思想?</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#_1341\\">五、并发队列</a></li>\\n<li>\\n<ul>\\n<li><a href=\\"#1__1342\\">1. 什么是并发队列：</a></li>\\n<li><a href=\\"#2__1346\\">2. 并发队列和并发集合的区别：</a></li>\\n<li><a href=\\"#3__1351\\">3. 怎么判断并发队列是阻塞队列还是非阻塞队列</a></li>\\n<li><a href=\\"#4__1355\\">4. 阻塞队列和非阻塞队列区别</a></li>\\n<li><a href=\\"#5__1363\\">5. 常用并发列队的介绍：</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#_1425\\">六、并发工具类</a></li>\\n<li>\\n<ul>\\n<li><a href=\\"#1__1426\\">1. 常用的并发工具类有哪些？</a></li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
