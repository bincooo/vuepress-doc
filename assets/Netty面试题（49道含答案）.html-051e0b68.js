import{_ as r,E as i,Z as o,$ as s,a0 as e,a3 as n,a1 as l,a4 as t}from"./framework-e0d053a9.js";const d={},c=t('<h3 id="目录" tabindex="-1"><a class="header-anchor" href="#目录" aria-hidden="true">#</a> 目录</h3><ul><li><a href="#1_Netty_2">1. Netty</a></li><li><a href="#2_BIO_10">2. BIO</a></li><li><a href="#3_IO__14">3. IO 模式</a></li><li><a href="#4__IO__19">4. 五种 I/O 模型</a></li><li><a href="#5__IO_23">5. 阻塞 IO</a></li><li><a href="#6__IO_25">6. 非阻塞 IO</a></li><li><a href="#7_IO__27">7. IO 多路复用</a></li><li><a href="#8__32">8. 信号驱动</a></li><li><a href="#9__IO_34">9. 异步 IO</a></li><li><a href="#10IO__47">10.IO 多路复用</a></li><li><a href="#11_select_52">11. select</a></li><li><a href="#12_poll_61">12. poll</a></li><li><a href="#13_epoll_65">13. epoll</a></li><li><a href="#14_Javaio_85">14. Java的i/o</a></li><li><a href="#15_Netty__Reactor__91">15. Netty 线程模型和 Reactor 模式</a></li><li><a href="#16_Reactor__102">16. Reactor 单线程模型</a></li><li><a href="#17_Reactor__109">17. Reactor 多线程模型</a></li><li><a href="#18_Reactor__114">18. Reactor 主从线程模型</a></li><li><a href="#19_Netty__NIO__AIO_119">19. Netty 使用 NIO 而不是 AIO</a></li><li><a href="#20_Echo_124">20. Echo服务</a></li><li><a href="#21_EventLoopEventLoopGroup_127">21. EventLoop和EventLoopGroup</a></li><li><a href="#22_Bootstrap_135">22. Bootstrap</a></li><li><a href="#23_channel_147">23. channel</a></li><li><a href="#24_childHandler_151">24. childHandler</a></li><li><a href="#25_childOption_154">25. childOption</a></li><li><a href="#26_option_157">26. option</a></li><li><a href="#27_childOption_174">27. childOption</a></li><li><a href="#28_childHandler_177">28. childHandler</a></li><li><a href="#29_Channel_180">29. Channel</a></li><li><a href="#30_ChannelHandlerChannelPipeline_201">30. ChannelHandler和ChannelPipeline</a></li><li><a href="#31_ChannelHandlerContext_214">31. ChannelHandlerContext</a></li><li><a href="#32_Handler_226">32. Handler执行顺序</a></li><li><a href="#33_ChannelFuture_242">33. ChannelFuture</a></li><li><a href="#34_ChannelPromise_252">34. ChannelPromise</a></li><li><a href="#35__255">35. 编解码</a></li><li><a href="#36_Netty_Decoder_268">36. Netty解码器 Decoder</a></li><li><a href="#37_Netty__Encoder_288">37. Netty 编码器 Encoder</a></li><li><a href="#38_Netty__Codec_295">38. Netty 组合编解码器 Codec</a></li><li><a href="#39_TCP__300">39. TCP 粘包，拆包</a></li><li><a href="#40_TCP__307">40. TCP 半包读写解决方案</a></li><li><a href="#41_Netty__TCP__317">41. Netty 自带解决 TCP 半包读写方案</a></li><li><a href="#42__323">42. 实战半包读写</a></li><li><a href="#43__TCP__326">43. 自定义分隔符解决 TCP 读写问题</a></li><li><a href="#44__LengthFieldBasedFrameDecoder_333">44. 自定义长度半包读写器 LengthFieldBasedFrameDecoder</a></li><li><a href="#45_ByteBuf_341">45. ByteBuf</a></li><li><a href="#46_ByteBuf__351">46. ByteBuf 创建方法与常见的模式</a></li><li><a href="#47_Netty__369">47. Netty 设计模式</a></li><li><a href="#48_Netty__373">48. Netty 单机百万实战</a></li><li><a href="#49__405">49. 数据链路</a></li></ul><h2 id="_1-netty" tabindex="-1"><a class="header-anchor" href="#_1-netty" aria-hidden="true">#</a> 1. Netty</h2><p>最流行的 NIO 框架，由 JBOSS 提供的，整合了FTP,SMTP,HTTP协议</p><ol><li>API 简单</li><li>成熟稳定</li><li>社区活跃·</li><li>经过大规模验证（互联网、大数据、网络游戏、电信通信）<br> Elasticsearch、Hadoop 子项目 avro项目、阿里开源框架 Dubbo、使用 Netty</li></ol><h2 id="_2-bio" tabindex="-1"><a class="header-anchor" href="#_2-bio" aria-hidden="true">#</a> 2. BIO</h2><p>优点：模型简单，编码简单缺点：性能瓶颈，请求数和线程数 N:N 关系高并发情况下 ,CPU 切换线程上<br> 下文损耗大案例：Tomcat 7之前，都是 BIO，7 之后是 NIO改进：伪 NIO，使用线程池去处理逻辑</p><h2 id="_3-io-模式" tabindex="-1"><a class="header-anchor" href="#_3-io-模式" aria-hidden="true">#</a> 3. IO 模式</h2><p>同步阻塞：丢衣服-&gt;等洗衣机洗完-&gt;再去晾衣服同步非阻塞：丢衣服-&gt;去做其他事情，定时去看衣服是<br> 否洗完-&gt;洗完后自己去晾衣服异步非阻塞：丢衣服-&gt; 去做其他事情不管了，衣服洗好会自动晾好，并且<br> 通知你晾好了</p><h2 id="_4-五种-i-o-模型" tabindex="-1"><a class="header-anchor" href="#_4-五种-i-o-模型" aria-hidden="true">#</a> 4. 五种 I/O 模型</h2><p>五种 I/O 模型：阻塞 IO、非阻塞 IO、多路复用 IO、信号驱动 IO、异步 IO，前 4 种是同步 IO，在内核<br> 数据 copy 到用户空间时是阻塞的</p><h2 id="_5-阻塞-io" tabindex="-1"><a class="header-anchor" href="#_5-阻塞-io" aria-hidden="true">#</a> 5. 阻塞 IO</h2><figure><img src="https://img-blog.csdnimg.cn/23a9737928014b69bd0d38e6fb863645.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h2 id="_6-非阻塞-io" tabindex="-1"><a class="header-anchor" href="#_6-非阻塞-io" aria-hidden="true">#</a> 6. 非阻塞 IO</h2><figure><img src="https://img-blog.csdnimg.cn/96c926f2b66147c49345ef17209dba3c.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h2 id="_7-io-多路复用" tabindex="-1"><a class="header-anchor" href="#_7-io-多路复用" aria-hidden="true">#</a> 7. IO 多路复用</h2><p><img src="https://img-blog.csdnimg.cn/7409f6899e124201afc858bca493eee2.png" alt="在这里插入图片描述" loading="lazy"><br> 核心：可以同时处理多个 connection，调用系统 select 和 recvfrom函数每一个socket 设置为 nonblocking 阻塞是被 select 这个函数 block 而不是 socket阻塞缺点：连接数不高的情况下，性能不一定<br> 比 多线程+ 阻塞 IO 好（多调用一个select 函数）</p><h2 id="_8-信号驱动" tabindex="-1"><a class="header-anchor" href="#_8-信号驱动" aria-hidden="true">#</a> 8. 信号驱动</h2><figure><img src="https://img-blog.csdnimg.cn/3e91c8ae36444e0ab55b558a2bb0d194.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h2 id="_9-异步-io" tabindex="-1"><a class="header-anchor" href="#_9-异步-io" aria-hidden="true">#</a> 9. 异步 IO</h2><p>采用 Future-Listener机制<br><img src="https://img-blog.csdnimg.cn/5043fa9ead4f4408a9d4de8363df0634.png" alt="在这里插入图片描述" loading="lazy"><br> IO 操作分为 2 步：</p><ol><li>发起 IO 请求，等待数据准备</li><li>实际的 IO 操作，将数据从内核拷贝到进程中<br> 阻塞 IO、非阻塞 IO 区别在于发起 IO 请求是否被阻塞<br> 同步 IO、异步 IO 在于实际的 IO 读写是否阻塞请求进程<br> 阻塞非阻塞是线程的状态<br> 同步和异步是消息的通知机制<br> 同步需要主动读写数据，异步不需要主动读写数据<br> 同步 IO 和异步 IO 是针对用户应用程序和内核的交互</li></ol>',22),h={id:"_10-io-多路复用",tabindex:"-1"},p=e("a",{class:"header-anchor",href:"#_10-io-多路复用","aria-hidden":"true"},"#",-1),_={href:"http://10.IO",target:"_blank",rel:"noopener noreferrer"},u=t(`<p>I/O 是指网络 I /O ，多路指多个 TCP 连接，复用指一个或几个线程。简单来说：就是使用一个或者几个<br> 线程处理多个 TCP 连接，最大优势是减少系统开销，不必创建过多的线程进程，也不必维护这些线程进<br> 程</p><h2 id="_11-select" tabindex="-1"><a class="header-anchor" href="#_11-select" aria-hidden="true">#</a> 11. select</h2><p>文件描述符 writefds、readdfs、exceptfds30w个连接会阻塞住，等数据可读、可写、出异常、或者超<br> 时返回select 函数正常返回后，通过遍历 fdset整个数组才能发现哪些句柄发生了事件，来找到就绪的<br> 描述符fd，然后进行对应的 IO操作，几乎在所有的平台上支持，跨平台支持性好缺点：</p><ol><li>select采用轮询的方式扫描文件描述符，全部扫描，随着文件描述符 FD 数量增多而性能下降。</li><li>每次调用 slect ()，需要把 fd集合从用户态拷贝到内核态，并进行遍历（消息传递都是内核到用户<br> 空间）</li><li>最大缺陷就是单个进程打开的FD 有限制，默认是 1024</li></ol><h2 id="_12-poll" tabindex="-1"><a class="header-anchor" href="#_12-poll" aria-hidden="true">#</a> 12. poll</h2><p>基本流程和 select差不多，处理多个描述符也是轮询，根据描述符的状态进行处理，一样需要把fd集合<br> 从用户态拷贝到内核态，并进行遍历。区别是poll 没有最大文件描述符限制（使用链表方式存储fd）</p><h2 id="_13-epoll" tabindex="-1"><a class="header-anchor" href="#_13-epoll" aria-hidden="true">#</a> 13. epoll</h2><p>没有描述符限制，用户态拷贝到内核态只需要一次使用事件通知，通过epoll_ctl注册fd,一旦该fd 就绪，<br> 内核就采用callback机制激活对应的fd优点：</p><ol><li>没有fd限制，所支持的 FD 上限是操作系统的最大文件句柄数（65535），1G 内存大概支持 10W<br> 句柄，支持百万连接的话，16G 内存就可以搞定</li><li>效率高，使用回调通知而不是轮询方式，不会随着 FD 数目增加效率下降</li><li>通过 callback 机制通知，内核和用户空间 mmap 同一块内存实现<br> 缺点：<br> 编程模型比 select / poll 复杂<br> linux内核核心函数</li><li>epoll_create() 系统启动时，会向linux内核申请一个文件系统，b+树，返回epoll 对象，也是一个<br> fd</li><li>epoll_ctl() 操作epoll对象，在这个对象里面修改添加删除对应的链接fd，绑定一个callback函数</li><li>epoll_wait() 判断并完成对应的 IO 操作<br> 例子：100W 个连接，1W 个活跃，在 select ,poll,epoll中怎么样表现<br> select :不修改宏定义，需要 1000 个进程才能支持 100W 连接<br> poll:100W连接，遍历都响应不过来，还有空间的拷贝消耗大量的资源<br> epoll: 不用遍历fd,不用内核空间和用户空间数据的拷贝<br> 如果 100W 个连接中，95W 活跃，则 poll 和 epoll差不多</li></ol><h2 id="_14-java的i-o" tabindex="-1"><a class="header-anchor" href="#_14-java的i-o" aria-hidden="true">#</a> 14. Java的i/o</h2><ol><li>jdk1.4之前是采用同步阻塞模型（BIO）<br> 大型服务一般采用 C/C++,因为可以直接操作系统提供的异步 IO（AIO）</li><li>jdk1.4之后推出NIO,支持非阻塞 IO，jdk1.7 升级推出 NIO2.0，提供了AIO 功能，支持文件和网络<br> 套接字的异步 IO</li></ol><h2 id="_15-netty-线程模型和-reactor-模式" tabindex="-1"><a class="header-anchor" href="#_15-netty-线程模型和-reactor-模式" aria-hidden="true">#</a> 15. Netty 线程模型和 Reactor 模式</h2><p>Reactor模式（反应器设计模式），是一种基于事件驱动的设计模式，在事件驱动的应用中，将一个或<br> 者多个客户的请求进行分离和调度。在事件驱动的应用中，同步地，有序地处理接受多个服务请求。属<br> 于同步非阻塞 IO优点：</p><ol><li>响应快，不会因为单个同步而阻塞，虽然 reactor本身是同步的</li><li>编程相对简单，最大程度避免复杂的多线程以及同步问题，避免了多线程、进程切换开销</li><li>可扩展性，可以方便的通过 reactor实例个数充分利用 CPU 资源<br> 缺点：</li><li>相对复杂，不易于调试</li><li>reactor模式需要系统底层的支持。比如java中的selector支持，操作系统select系统调用支持</li></ol><h2 id="_16-reactor-单线程模型" tabindex="-1"><a class="header-anchor" href="#_16-reactor-单线程模型" aria-hidden="true">#</a> 16. Reactor 单线程模型</h2><ol><li>作为 NIO 服务器，接受客户端 TCP 连接，作为 NIO 客户端，向服务端发起 TCP 连接</li><li>服务端读请求数据并响应，客户端写请求并读取响应<br> 场景：<br> 对应小业务则适合，编码简单，对于高负载，高并发不合适。一个 NIO 线程处理太多请求，负载<br> 很高，并且响应变慢，导致大量请求超时，万一线程挂了，则不可用</li></ol><h2 id="_17-reactor-多线程模型" tabindex="-1"><a class="header-anchor" href="#_17-reactor-多线程模型" aria-hidden="true">#</a> 17. Reactor 多线程模型</h2><p>一个 Acceptor线程，一组 NIO 线程，一般是使用自带线程池，包含一个任务队列和多个可用线程场<br> 景：可满足大多数场景，当Acceptor需要做负责操作的时候，比如认证等耗时操作 ，在高并发情况下<br> 也会有性能问题</p><h2 id="_18-reactor-主从线程模型" tabindex="-1"><a class="header-anchor" href="#_18-reactor-主从线程模型" aria-hidden="true">#</a> 18. Reactor 主从线程模型</h2><p>Acceptor不在是一个线程，而是一组 NIO 线程，IO 线程也是一组 NIO 线程，这样就是 2 个线程池去处<br> 理接入和处理 IO场景：满足目前大部分场景，也是 Netty推荐使用的线程模型BossGroup 处理连接的<br> WorkGroup 处理业务的</p><h2 id="_19-netty-使用-nio-而不是-aio" tabindex="-1"><a class="header-anchor" href="#_19-netty-使用-nio-而不是-aio" aria-hidden="true">#</a> 19. Netty 使用 NIO 而不是 AIO</h2><p>在 linux系统上，AIO 的底层实现仍然使用 epoll，与 NIO 相同，因此在性能上没有明显的优势Netty 整<br> 体架构是 reactor 模型，采用 epoll机制，IO 多路复用，同步非阻塞模型Netty是基于 Java NIO 类库实<br> 现的异步通讯框架特点： 异步非阻塞，基于事件驱动，性能高，高可靠性，高可定制性。</p><h2 id="_20-echo服务" tabindex="-1"><a class="header-anchor" href="#_20-echo服务" aria-hidden="true">#</a> 20. Echo服务</h2><p>回显服务，用于调试和检测的服务</p><h2 id="_21-eventloop和eventloopgroup" tabindex="-1"><a class="header-anchor" href="#_21-eventloop和eventloopgroup" aria-hidden="true">#</a> 21. EventLoop和EventLoopGroup</h2><p>高性能 RPC框架 3 个要素：IO 模型、数据协议（http,brotobuf/thrift）、线程模型EventLoop 好比一<br> 个线程，一个 EventLoop可以服务多个Channel,一个Channel只有一个EventLoop，可以创建多个<br> EventLoop来优化资源的利用，也就是EventLoopGroup一个Cahnnel 一个连接，EventLoopGroup 负<br> 责 EventLoop<br> NIO（单线程处理多个Channels） BIO（一个线程处理一个Channels）事件：<br> accept,connect,read,writeEventLoopGroup 默认创建线程数是 CPU 核数 * 2</p><h2 id="_22-bootstrap" tabindex="-1"><a class="header-anchor" href="#_22-bootstrap" aria-hidden="true">#</a> 22. Bootstrap</h2><ol><li><p>group:设置线程中模型，Reactor线程模型对比EventLoopGroup</p></li><li><p>单线程</p></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">EventLoopGroup</span> g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ServerBootstrap</span> strap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
strap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span>复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>多线程</li><li>主从线程</li></ol><h2 id="_23-channel" tabindex="-1"><a class="header-anchor" href="#_23-channel" aria-hidden="true">#</a> 23. channel</h2><p>NioServerSocketChannelOioServerSocketChannelEpollServerSocketChannelKQueueServerSocket<br> Channel</p><h2 id="_24-childhandler" tabindex="-1"><a class="header-anchor" href="#_24-childhandler" aria-hidden="true">#</a> 24. childHandler</h2><p>用于对每个通道里面的数据处理</p><h2 id="_25-childoption" tabindex="-1"><a class="header-anchor" href="#_25-childoption" aria-hidden="true">#</a> 25. childOption</h2><p>作用于被 accept之后的连接</p><h2 id="_26-option" tabindex="-1"><a class="header-anchor" href="#_26-option" aria-hidden="true">#</a> 26. option</h2><p>作用于每个新建立的 channel，设置 TCP 连接中的一些参数</p>`,38),b={href:"http://ChannelOption.SO",target:"_blank",rel:"noopener noreferrer"},f=e("br",null,null,-1),g=e("br",null,null,-1),m=e("br",null,null,-1),k=e("br",null,null,-1),C=e("br",null,null,-1),y=e("br",null,null,-1),v=e("li",null,[n("ChannelOption.TCP_NODELAY"),e("br"),n(" 默认是 false，要求高实时性，有数据时马上发送，就将该值改为 true 关闭 Nagle 算法 （Nagle"),e("br"),n(" 算法会积累一定大小后再发送，为了减少发送次数）Nagle算法只允许一个未被 ACK 的包存在于"),e("br"),n(" 网络"),e("br"),n(" （tcp_synack_retries = 0 加快回收半连接，如果收不到第三个握手包 ACK，不进行重试,默认值是"),e("br"),n(" 5，每次等待 30S，半连接会 hold住大约 180s,tcp_syn_retries 默认值是 5，客户端没收到"),e("br"),n(" SYN+ACK 包，客户端也会重试 5 次发送 SYN 包)")],-1),O=t(`<h2 id="_27-childoption" tabindex="-1"><a class="header-anchor" href="#_27-childoption" aria-hidden="true">#</a> 27. childOption</h2><p>作用于被 accept之后的链接</p><h2 id="_28-childhandler" tabindex="-1"><a class="header-anchor" href="#_28-childhandler" aria-hidden="true">#</a> 28. childHandler</h2><p>用于对每个通道里面的数据处理</p><h2 id="_29-channel" tabindex="-1"><a class="header-anchor" href="#_29-channel" aria-hidden="true">#</a> 29. Channel</h2><ul><li>Channel<br> 客户端和服务端建立的一个连接通道</li><li>ChannelHandler<br> 负责Channel的逻辑处理</li><li>ChannelPipeline<br> 负责管理 ChannelHandler的有序容器<br> 一个Channel包含一个ChannelPipeline，所有 ChannelHandler都会顺序加入到ChannelPipeline中。<br> Channel当状态出现变化，对触发对应的事件</li></ul><p><img src="https://img-blog.csdnimg.cn/e4f8e65e01614d7c8fa8129e91904e90.png" alt="在这里插入图片描述" loading="lazy"><br> 状态：</p><ul><li>channelRegistered<br> channel注册到一个EventLoop，和Selector绑定</li><li>channelUnRegistered<br> channel已创建，但是未注册到一个EventLoop里面，也就是没有和Selector绑定</li><li>channelActive<br> 变为活跃状态，连接到了远程主机，可以接受和发送数据</li><li>channelInActive<br> channel处于非活跃状态，没有连接到远程主机</li></ul><h2 id="_30-channelhandler和channelpipeline" tabindex="-1"><a class="header-anchor" href="#_30-channelhandler和channelpipeline" aria-hidden="true">#</a> 30. ChannelHandler和ChannelPipeline</h2><p>ChannelHandler生命周期：handlerAdded:当ChannelHandler添加到ChannelPipeline调用<br> handlerRemoved:当ChannelHandler从ChannelPipeline移除时调用exceptionCaught:执行抛出异常<br> 时调用ChannelHandler有 2 个子接口：<br><img src="https://img-blog.csdnimg.cn/ef58a9e68a2e48929b06cbec07c75214.png" alt="在这里插入图片描述" loading="lazy"><br> ChannelInboundHandler（入站）： 处理输入数据和Channel状态类型改变，适配器<br> ChannelInboundHandlerAdapter（适配器设计模式）,常用<br> SimpleChannelInboundHandlerChannelOutboundHandler（出站）：处理输出数据，适配器<br> Channel<br> ChannelPipeline:好比厂里的流水线一样，可以在上面添加多个ChannelHandler，也可以看成是一串<br> ChannelHandler 实例，拦截穿过Channel的输入输出 event，ChannelPileline实现了拦截器的一种高<br> 级形式，使得用户可以对事件的处理以及ChannelHandler之间交互获得完全的控制权</p><h2 id="_31-channelhandlercontext" tabindex="-1"><a class="header-anchor" href="#_31-channelhandlercontext" aria-hidden="true">#</a> 31. ChannelHandlerContext</h2><figure><img src="https://img-blog.csdnimg.cn/49f89bc181444ce4a78880e6d383e6a6.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><ol><li>channelHandlerContext 是连接 ChannelHandler 和 ChannelPipeline 的桥梁<br> ChannelHandlerContext 部分方法是和 Channel以及ChannelPipleline重合，好比调用 write方法<br> Channel,ChannelPipeline,ChannelHandlerContext都可以调用写方法，前 2 者会在整个管道流<br> 里传播，而 ChannelHandlerContext只会在后续的 Handler里传播</li><li>AbstractChannelHandlerContext<br> 双向链表结构,next/prev 后继、前驱节点</li><li>DefaultChannelHandlerContext 是实现类，但是大部分都是父类完成，整个只是简单的实现一些<br> 方法，主要就是判断 Handler的类型<br> fire调用下一个 handler，不fire就不调用</li></ol><h2 id="_32-handler执行顺序" tabindex="-1"><a class="header-anchor" href="#_32-handler执行顺序" aria-hidden="true">#</a> 32. Handler执行顺序</h2><p>InboundHandler顺序执行，OutboundHandler逆序执行</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutboundHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutboundHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InboundHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
channel<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InboundHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>InboundHandler1 InboundHandler2 OutboundHandler2 OutboundHandler1InboundHandler1之<br> 间通过 fireChannelRead()方法调用InboundHandler通过ctx.write(msg),传递到<br> OutboundHandlerctx.write(msg)传递消息，Inbound需要放在结尾，在 outbound之后，不然<br> outboundHandler不会执行，使用 channel.write(msg),或者 pipline.write(msg)，就不用考虑（传播<br> 机制）客户端： 发起请求再接受请求，先 outbound再inbound服务端：先接受请求再发送请求，先<br> inbound再outbound</p><h2 id="_33-channelfuture" tabindex="-1"><a class="header-anchor" href="#_33-channelfuture" aria-hidden="true">#</a> 33. ChannelFuture</h2><p>netty中所有 I/0 操作都是异步的，意味着任何 I/0 调用都会立即返回，而ChannelFuture会提供有关的<br> 信息 I/0 操作的结果或状态未完成：当 I/0 操作开始时，将创建一个新的对象，新的最初是未完成的，<br> 它既没有成功，也没有被取消，因为 I/0 操作尚未完成。已完成：当 I/0 操作完成，不管是成功、失败<br> 还是取消，Future都是标记为已完成的，失败的时候也有具体的信息，例如原因失败，但请注意，即使<br> 失败和取消属于完成状态。<br><img src="https://img-blog.csdnimg.cn/33d6c643604645239caf345217c107eb.png" alt="在这里插入图片描述" loading="lazy"><br> 注意：不要在 IO 线程内调用Future对象的sync和await方法，不能在 channelhandler中调用 sync 和<br> await</p><h2 id="_34-channelpromise" tabindex="-1"><a class="header-anchor" href="#_34-channelpromise" aria-hidden="true">#</a> 34. ChannelPromise</h2><p>继承 ChannelFuture，进一步扩展用于设置 IO 操作的结果</p><h2 id="_35-编解码" tabindex="-1"><a class="header-anchor" href="#_35-编解码" aria-hidden="true">#</a> 35. 编解码</h2><p>java序列化/反序列化，url编解码,base64编解码java自带序列化的缺点：</p><ol><li>无法跨语言</li><li>序列化后的码流太大，数据包太大</li><li>序列化和反序列化性能比较差</li></ol><p>业界其他编解码框架：PB，Thrift，Marshalling，Kyro<br> Netty里面的编解码：</p><ul><li>解码器：主要负责处理入站 InboundHandler</li><li>编码器: 主要负责处理出站 OutBoundHandler<br> Netty默认编解码器，也支持自定义编解码器<br> Encoder（编码器）,Decoder（解码器）,Codec（编解码器）</li></ul><h2 id="_36-netty解码器-decoder" tabindex="-1"><a class="header-anchor" href="#_36-netty解码器-decoder" aria-hidden="true">#</a> 36. Netty解码器 Decoder</h2><p>Decoder对应 ChannelInboundHandler，主要就是字节数组转换成消息对象方法：</p><ul><li>decode :常用</li><li>decodeLast: 用于最后的几个字节处理，也就是 cahnnel 关闭的时候，产生的最后一个消息<br> 解码器：</li><li>ByteToMessageDecoder<br> 用于将字节转为消息，需要检查缓冲区是否有足够的字节</li><li>ReplayingDecoder<br> 继承ByteToMessageDecoder，不需要检查缓冲区是否有足够多的数据，速度略慢于<br> ByteToMessageDecoder</li><li>MessageToMessageDecoder<br> 用于将一种消息解码到另外一种消息（例如 POJO 到 POJO）<br> 常用的解码器：（主要解决 TCP 底层的粘包和拆包问题）</li><li>DelimiterBasedFrameDecoder：执行消息分隔符的解码器</li><li>LineBasedFrameDecoder：以换行符为结束标志的解码器</li><li>FixedLengthFrameDecoder：固定长度的解码器</li><li>LengthFieldBasedFrameDecoder: message = header + body,基于长度解码的通用解码器</li><li>StringDecoder:文本解码器，将接收到的消息转为字符串，一般会与上面的几种进行组合，然后再<br> 后面加业务的 handler</li></ul><h2 id="_37-netty-编码器-encoder" tabindex="-1"><a class="header-anchor" href="#_37-netty-编码器-encoder" aria-hidden="true">#</a> 37. Netty 编码器 Encoder</h2><p>Encoder 对应就是 ChannelOutboundHandler ，消息对象转换成字节数组编码器：</p><ul><li>MessageToByteEncoder<br> 消息转为字节数组，调用 write方法，会先判断当前编码器是否支持需要发送的消息类型，如果不<br> 支持，则透传</li><li>MessageToMessageEncoder 从一种消息编码为另外一种消息</li></ul><h2 id="_38-netty-组合编解码器-codec" tabindex="-1"><a class="header-anchor" href="#_38-netty-组合编解码器-codec" aria-hidden="true">#</a> 38. Netty 组合编解码器 Codec</h2><p>优点：成对出现，编解码都是在一个类里完成缺点：耦合，扩展性不佳</p><ul><li>ByteToMessageCodec</li><li>MessageToMessageCode</li></ul><h2 id="_39-tcp-粘包-拆包" tabindex="-1"><a class="header-anchor" href="#_39-tcp-粘包-拆包" aria-hidden="true">#</a> 39. TCP 粘包，拆包</h2><p><img src="https://img-blog.csdnimg.cn/759ea5ac6c1442ea9f7b52e9eac50286.png" alt="在这里插入图片描述" loading="lazy"><br> TCP 拆包：一个完整的包可能被 TCP 拆分成多个包进行发送TCP 粘包：把多个小的包封装成一个大的<br> 数据包发送,client发送的若干数据包， server接收时粘在一个包发送方和接收方都可能出现这个原因发<br> 送方的原因：TCP 默认会使用 Nagle算法接收方的原因：TCP 接收到数据放置缓存中，应用程序从缓存<br> 中读取比较慢UDP 无粘包、拆包问题，有边界协议</p><h2 id="_40-tcp-半包读写解决方案" tabindex="-1"><a class="header-anchor" href="#_40-tcp-半包读写解决方案" aria-hidden="true">#</a> 40. TCP 半包读写解决方案</h2><p>发送方：关闭 Nagle 算法接收方：TCP 是无界的数据流，并没有处理粘包现象的机制，且协议本身无法<br> 避免粘包，半包读写的发生需要在应用层进行处理应用层解决半包读写方法：</p><ol><li>设置定长消息 (10 个字符)<br> abcdefgh11abcdefgh11abcdefgh11</li><li>设置消息边界 (?切割)<br> dfdsfdsfdf?dsfsdfdsf$dsfdsfsdf</li><li>使用带消息头的协议，消息头存储消息开始标识及消息的长度信息<br> header + body</li></ol><h2 id="_41-netty-自带解决-tcp-半包读写方案" tabindex="-1"><a class="header-anchor" href="#_41-netty-自带解决-tcp-半包读写方案" aria-hidden="true">#</a> 41. Netty 自带解决 TCP 半包读写方案</h2><p>DelimiterBasedFrameDecoder:指定消息分隔符的解码器<br> LineBasedFrameDecoder:以换行符为结束标志的解码器<br> FixedLengthFrameDecoder:固定长度解码器<br> LengthFieldBasedFrameDecoder : message = header + body ，基于长度解码的通用解码器</p><h2 id="_42-实战半包读写" tabindex="-1"><a class="header-anchor" href="#_42-实战半包读写" aria-hidden="true">#</a> 42. 实战半包读写</h2><p>LineBasedFrameDecoder:以换行符为结束标志的解码器StringDecoder 解码器将对象转成字符串</p><h2 id="_43-自定义分隔符解决-tcp-读写问题" tabindex="-1"><a class="header-anchor" href="#_43-自定义分隔符解决-tcp-读写问题" aria-hidden="true">#</a> 43. 自定义分隔符解决 TCP 读写问题</h2><p>DelimiterBasedFrameDecodermaxLength: 表示一行最大的长度，超过长度依然没检测自定义分隔<br> 符，抛出TooLongFrameExceptionfailFast: 如果为true,则超过 maxLength后立即抛出<br> TooLongFrameException,不进行继续解码，如果为 false,则等到完整消息被解码后，再抛出<br> TooLongFrameExceptionstripDelimiter:解码后的消息是否去除分隔符delimiters:分隔符，ByteBuf类<br> 型</p><h2 id="_44-自定义长度半包读写器-lengthfieldbasedframedecoder" tabindex="-1"><a class="header-anchor" href="#_44-自定义长度半包读写器-lengthfieldbasedframedecoder" aria-hidden="true">#</a> 44. 自定义长度半包读写器 LengthFieldBasedFrameDecoder</h2><p>maxFrameLength 数据包最大长度lengthFieldOffset 长度字段的偏移量，长度字段开始的地方（跳过<br> 指定长度个字节之后的才是消息体字段）lengthFieldLength 长度字段占的字节数，帧数据长度的字段<br> 本身的长度lengthAdjustment一般 Header + Body ,添加到长度字段的补偿值，如果为负数，开发人员<br> 认为这个Header的长度字段是整个消息包的长度，，则Netty应该减去对应的数字initialBytesToStrip<br> 从解码帧中第一次去除的字节数，获取完一个完整的数据包之后，忽略前面的指定位数的长度字节，应<br> 用解码器拿到的就是不带长度域的数据包</p><h2 id="_45-bytebuf" tabindex="-1"><a class="header-anchor" href="#_45-bytebuf" aria-hidden="true">#</a> 45. ByteBuf</h2><p><img src="https://img-blog.csdnimg.cn/705a64508c534e9684f59a12acf366bb.png" alt="在这里插入图片描述" loading="lazy"><br> 字节容器，</p><ul><li>JDK 中原生 ByteBuffer<br> 读和写公用一个索引，每次换操作都需要Flip()<br> 扩容麻烦，而且扩容后容易造成浪费</li><li>Netty ByteBuf<br> 读写使用不同的索引，所以操作便捷<br> 自动扩容，便捷</li></ul><h2 id="_46-bytebuf-创建方法与常见的模式" tabindex="-1"><a class="header-anchor" href="#_46-bytebuf-创建方法与常见的模式" aria-hidden="true">#</a> 46. ByteBuf 创建方法与常见的模式</h2><p>ByteBuf:传递字节数据的容器ByteBuf的创建方法：</p><ol><li>ByteBufAllocator<br> Netty 4.x之后默认使用池化（PooledByteBufAllocator）提高性能，最大程度减少内存碎片<br> 非池化：UnPooledByteBufAllocator 每次返回一个新的实例</li><li>Unpooled:提供静态方法创建未池化的ByteBuf，可以创建堆内存和直接内存缓冲区<br> ByteBuf使用模式：</li><li>堆缓存区<br> 优点：heap buffer 存储在 jvm的堆空间中，快速的分配和释放<br> 缺点：每次使用前会拷贝到直接缓存区 （堆外内存）</li><li>直接缓存区<br> Direct buffer<br> 优点：不用占用 JVM 的堆内存，存储在堆外内存<br> 缺点：内存的分配和释放，比在堆缓存区更复杂</li><li>复合缓冲区<br> 创建多个不同的 ByteBuf,然后放在一起，但是只是一个视图<br> 选择：大量 IO 数据读写，用直接缓存区，业务消息编解码用堆缓存区</li></ol><h2 id="_47-netty-设计模式" tabindex="-1"><a class="header-anchor" href="#_47-netty-设计模式" aria-hidden="true">#</a> 47. Netty 设计模式</h2><p>Builder 构造器模式：ServerBootstrap责任链设计模式：pipeline的事件传播工厂模式：创建 channel<br> 适配器模式：HandlerAdapter</p><h2 id="_48-netty-单机百万实战" tabindex="-1"><a class="header-anchor" href="#_48-netty-单机百万实战" aria-hidden="true">#</a> 48. Netty 单机百万实战</h2><ol><li>网络 IO模型</li><li>Linux文件描述符<br> 单进程文件描述符（句柄数），每个进程都有最大的文件描述符限制<br> 全局文件句柄数，也有默认值，不同系统版本会不一样</li><li>如何确定唯一 TCP 连接<br> TCP 四元组：源 IP，源端口，目标 IP，目标端口<br> 服务端端口范围（1024~65535）<br><img src="https://img-blog.csdnimg.cn/78277bf8c8794271bb0e93ed1dae20d9.png" alt="在这里插入图片描述" loading="lazy"><br> 65545<br> 优化：</li><li>sudo vim /etc/security/limits.conf 修改局部 fd数目，修改后要重启，ulimit -n 查看当前这个用<br> 户每个进程最大 FD 数</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>root soft nofile <span class="token number">1000000</span>
root hard nofile <span class="token number">1000000</span>
<span class="token operator">*</span> soft nofile <span class="token number">1000000</span>
<span class="token operator">*</span> hard nofile <span class="token number">1000000</span>复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>sudo vim /etc/sysctl.conf 修改全局 fd 数目</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>fs<span class="token punctuation">.</span>file<span class="token operator">-</span>max<span class="token operator">=</span><span class="token number">1000000</span>复制代码
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>sysctl -p 重启生效参数cat /proc/sys/fs/file-max 查看全局fd数目</p><ol><li>重启生效 reboot</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token parameter variable">-Xms5g</span> <span class="token parameter variable">-Xmx5g</span> <span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span>3g <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span>3g
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_49-数据链路" tabindex="-1"><a class="header-anchor" href="#_49-数据链路" aria-hidden="true">#</a> 49. 数据链路</h2><p>浏览器同域名下资源加载有并发数限制，建议不同资源用不同域名输入域名-》浏览器内核调度-》本地<br> DNS 解析-》远程 DNS解析-》IP-》路由多层跳转-》目的服务器-》服务器内核-》应用程序</p><hr><p><strong>史上最全Java面试宝典，BAT大厂面试必备。整理不易，建议先关注点赞加收藏</strong></p>`,68),I=e("thead",null,[e("tr",null,[e("th",null,"序号"),e("th",null,"名称"),e("th",null,"地址")])],-1),x=e("td",null,"1",-1),N=e("td",null,"Java基础面试题（91道含答案）",-1),B={href:"https://blog.csdn.net/qq_30999361/article/details/124482581",target:"_blank",rel:"noopener noreferrer"},P=e("td",null,"2",-1),H=e("td",null,"Java并发编程面试题 （123道含答案）",-1),q={href:"https://blog.csdn.net/qq_30999361/article/details/124545403",target:"_blank",rel:"noopener noreferrer"},L=e("td",null,"3",-1),T=e("td",null,"Java异常面试题 （33道含答案）",-1),D={href:"https://blog.csdn.net/qq_30999361/article/details/124560006",target:"_blank",rel:"noopener noreferrer"},F=e("td",null,"4",-1),E=e("td",null,"Java虚拟机（JVM）面试题（51道含答案）",-1),S={href:"https://blog.csdn.net/qq_30999361/article/details/124532763",target:"_blank",rel:"noopener noreferrer"},A=e("td",null,"5",-1),w=e("td",null,"Java集合面试题（52道含答案）",-1),j={href:"https://blog.csdn.net/qq_30999361/article/details/124503952",target:"_blank",rel:"noopener noreferrer"},R=e("td",null,"6",-1),M=e("td",null,"Linux面试题（50道含答案）",-1),J={href:"https://blog.csdn.net/qq_30999361/article/details/124575798",target:"_blank",rel:"noopener noreferrer"},G=e("td",null,"7",-1),z=e("td",null,"Memcache面试题（23道含答案）",-1),U={href:"https://blog.csdn.net/qq_30999361/article/details/124596870",target:"_blank",rel:"noopener noreferrer"},W=e("td",null,"8",-1),K=e("td",null,"Mybatiss面试题 （37道含答案）",-1),V={href:"https://blog.csdn.net/qq_30999361/article/details/124560907",target:"_blank",rel:"noopener noreferrer"},X=e("td",null,"9",-1),Q=e("td",null,"MySQL面试题（40道含答案）",-1),Y={href:"https://blog.csdn.net/qq_30999361/article/details/124506169",target:"_blank",rel:"noopener noreferrer"},Z=e("td",null,"10",-1),$=e("td",null,"Netty面试题（49道含答案）",-1),ee={href:"https://blog.csdn.net/qq_30999361/article/details/124617122",target:"_blank",rel:"noopener noreferrer"},ne=e("td",null,"11",-1),ae=e("td",null,"Nginx面试题（23道含答案）",-1),le={href:"https://blog.csdn.net/qq_30999361/article/details/124597174",target:"_blank",rel:"noopener noreferrer"},te=e("td",null,"12",-1),re=e("td",null,"RabbitMQ面试题（22道含答案）",-1),ie={href:"https://blog.csdn.net/qq_30999361/article/details/124533998",target:"_blank",rel:"noopener noreferrer"},oe=e("td",null,"13",-1),se=e("td",null,"Redis面试题（70道含答案）",-1),de={href:"https://blog.csdn.net/qq_30999361/article/details/124459566",target:"_blank",rel:"noopener noreferrer"},ce=e("td",null,"14",-1),he=e("td",null,"SpringBoot面试题（44道含答案）",-1),pe={href:"https://blog.csdn.net/qq_30999361/article/details/124461725",target:"_blank",rel:"noopener noreferrer"},_e=e("td",null,"15",-1),ue=e("td",null,"SpringCloud面试题（49道含答案）",-1),be={href:"https://blog.csdn.net/qq_30999361/article/details/124430712",target:"_blank",rel:"noopener noreferrer"},fe=e("td",null,"16",-1),ge=e("td",null,"SpringMVC面试题（29道含答案）",-1),me={href:"https://blog.csdn.net/qq_30999361/article/details/124519135",target:"_blank",rel:"noopener noreferrer"},ke=e("td",null,"17",-1),Ce=e("td",null,"Spring面试题（75道含答案）",-1),ye={href:"https://blog.csdn.net/qq_30999361/article/details/124519472",target:"_blank",rel:"noopener noreferrer"},ve=e("td",null,"18",-1),Oe=e("td",null,"TCP、UDP、Socket、Http网络编程面试题（47道含答案）",-1),Ie={href:"https://blog.csdn.net/qq_30999361/article/details/124617792",target:"_blank",rel:"noopener noreferrer"},xe=e("td",null,"19",-1),Ne=e("td",null,"Tomcat面试题（15道含答案）",-1),Be={href:"https://blog.csdn.net/qq_30999361/article/details/124576964",target:"_blank",rel:"noopener noreferrer"},Pe=e("td",null,"20",-1),He=e("td",null,"Zookeeper面试题（28道含答案）",-1),qe={href:"https://blog.csdn.net/qq_30999361/article/details/124596208",target:"_blank",rel:"noopener noreferrer"},Le=e("td",null,"21",-1),Te=e("td",null,"多线程面试题（60道含答案）",-1),De={href:"https://blog.csdn.net/qq_30999361/article/details/124596462",target:"_blank",rel:"noopener noreferrer"},Fe=e("td",null,"22",-1),Ee=e("td",null,"设计模式面试题（14道含答案）",-1),Se={href:"https://blog.csdn.net/qq_30999361/article/details/124637874",target:"_blank",rel:"noopener noreferrer"},Ae=e("td",null,"23",-1),we=e("td",null,"BIO、NIO、AIO、Netty面试题（35道含答案）",-1),je={href:"https://blog.csdn.net/qq_30999361/article/details/124653616",target:"_blank",rel:"noopener noreferrer"},Re=e("td",null,"24",-1),Me=e("td",null,"Dubbo面试题（47道含答案）",-1),Je={href:"https://blog.csdn.net/qq_30999361/article/details/124637288",target:"_blank",rel:"noopener noreferrer"},Ge=e("td",null,"25",-1),ze=e("td",null,"ElasticSearch面试题（31道含答案）",-1),Ue={href:"https://blog.csdn.net/qq_30999361/article/details/124619240",target:"_blank",rel:"noopener noreferrer"},We=e("td",null,"26",-1),Ke=e("td",null,"Git常用命令（63条）",-1),Ve={href:"https://blog.csdn.net/qq_30999361/article/details/124438420",target:"_blank",rel:"noopener noreferrer"};function Xe(Qe,Ye){const a=i("ExternalLinkIcon");return o(),s("div",null,[c,e("h2",h,[p,n(),e("a",_,[n("10.IO"),l(a)]),n(" 多路复用")]),u,e("ul",null,[e("li",null,[e("a",b,[n("ChannelOption.SO"),l(a)]),n("_BACKLOG"),f,n(" 存放已完成三次握手的请求的等待队列的最大长度"),g,n(" Linux 服务器 TCP 连接底层知识："),m,n(" syn queue: 半连接队列，洪水攻击（伪造 IP 海量发送第一个握手包），tcp_max_syn_backlog"),k,n(" （修改半连接 vi /etc/sysctl.conf）"),C,n(" accept queue:全连接队列 net.core.somaxconn 当前机器最大连接数"),y,n(" 系统默认的somaxconn参数要足够大，如果 backlog 比 somaxconn大，则会优先用后者")]),v]),O,e("table",null,[I,e("tbody",null,[e("tr",null,[x,N,e("td",null,[e("a",B,[n("（点击查看）"),l(a)])])]),e("tr",null,[P,H,e("td",null,[e("a",q,[n("（点击查看）"),l(a)])])]),e("tr",null,[L,T,e("td",null,[e("a",D,[n("（点击查看）"),l(a)])])]),e("tr",null,[F,E,e("td",null,[e("a",S,[n("（点击查看）"),l(a)])])]),e("tr",null,[A,w,e("td",null,[e("a",j,[n("（点击查看）"),l(a)])])]),e("tr",null,[R,M,e("td",null,[e("a",J,[n("（点击查看）"),l(a)])])]),e("tr",null,[G,z,e("td",null,[e("a",U,[n("（点击查看）"),l(a)])])]),e("tr",null,[W,K,e("td",null,[e("a",V,[n("（点击查看）"),l(a)])])]),e("tr",null,[X,Q,e("td",null,[e("a",Y,[n("（点击查看）"),l(a)])])]),e("tr",null,[Z,$,e("td",null,[e("a",ee,[n("（点击查看）"),l(a)])])]),e("tr",null,[ne,ae,e("td",null,[e("a",le,[n("（点击查看）"),l(a)])])]),e("tr",null,[te,re,e("td",null,[e("a",ie,[n("（点击查看）"),l(a)])])]),e("tr",null,[oe,se,e("td",null,[e("a",de,[n("（点击查看）"),l(a)])])]),e("tr",null,[ce,he,e("td",null,[e("a",pe,[n("（点击查看）"),l(a)])])]),e("tr",null,[_e,ue,e("td",null,[e("a",be,[n("（点击查看）"),l(a)])])]),e("tr",null,[fe,ge,e("td",null,[e("a",me,[n("（点击查看）"),l(a)])])]),e("tr",null,[ke,Ce,e("td",null,[e("a",ye,[n("（点击查看）"),l(a)])])]),e("tr",null,[ve,Oe,e("td",null,[e("a",Ie,[n("（点击查看）"),l(a)])])]),e("tr",null,[xe,Ne,e("td",null,[e("a",Be,[n("（点击查看）"),l(a)])])]),e("tr",null,[Pe,He,e("td",null,[e("a",qe,[n("（点击查看）"),l(a)])])]),e("tr",null,[Le,Te,e("td",null,[e("a",De,[n("（点击查看）"),l(a)])])]),e("tr",null,[Fe,Ee,e("td",null,[e("a",Se,[n("（点击查看）"),l(a)])])]),e("tr",null,[Ae,we,e("td",null,[e("a",je,[n("（点击查看）"),l(a)])])]),e("tr",null,[Re,Me,e("td",null,[e("a",Je,[n("（点击查看）"),l(a)])])]),e("tr",null,[Ge,ze,e("td",null,[e("a",Ue,[n("（点击查看）"),l(a)])])]),e("tr",null,[We,Ke,e("td",null,[e("a",Ve,[n("（点击查看）"),l(a)])])])])])])}const $e=r(d,[["render",Xe],["__file","Netty面试题（49道含答案）.html.vue"]]);export{$e as default};
